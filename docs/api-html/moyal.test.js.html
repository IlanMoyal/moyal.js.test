<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>moyal.test.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AreEqual.html">AreEqual</a></li><li><a href="AreNotEqual.html">AreNotEqual</a></li><li><a href="Assert.html">Assert</a></li><li><a href="AutoNumbering.html">AutoNumbering</a><ul class='methods'><li data-type='method'><a href="AutoNumbering.html#next">next</a></li></ul></li><li><a href="BrowserLogger.html">BrowserLogger</a><ul class='methods'><li data-type='method'><a href="BrowserLogger.html#error">error</a></li><li data-type='method'><a href="BrowserLogger.html#group">group</a></li><li data-type='method'><a href="BrowserLogger.html#groupCollapsed">groupCollapsed</a></li><li data-type='method'><a href="BrowserLogger.html#groupEnd">groupEnd</a></li><li data-type='method'><a href="BrowserLogger.html#info">info</a></li><li data-type='method'><a href="BrowserLogger.html#log">log</a></li><li data-type='method'><a href="BrowserLogger.html#warn">warn</a></li></ul></li><li><a href="IsDefined.html">IsDefined</a></li><li><a href="IsFalse.html">IsFalse</a></li><li><a href="IsNotNull.html">IsNotNull</a></li><li><a href="IsNull.html">IsNull</a></li><li><a href="IsTrue.html">IsTrue</a></li><li><a href="IsUndefined.html">IsUndefined</a></li><li><a href="LoggerBase.html">LoggerBase</a><ul class='methods'><li data-type='method'><a href="LoggerBase.html#error">error</a></li><li data-type='method'><a href="LoggerBase.html#group">group</a></li><li data-type='method'><a href="LoggerBase.html#groupCollapsed">groupCollapsed</a></li><li data-type='method'><a href="LoggerBase.html#groupEnd">groupEnd</a></li><li data-type='method'><a href="LoggerBase.html#info">info</a></li><li data-type='method'><a href="LoggerBase.html#isSupportedColor">isSupportedColor</a></li><li data-type='method'><a href="LoggerBase.html#log">log</a></li><li data-type='method'><a href="LoggerBase.html#normalizeColor">normalizeColor</a></li><li data-type='method'><a href="LoggerBase.html#warn">warn</a></li><li data-type='method'><a href="LoggerBase.html#.getDefaultLogger">getDefaultLogger</a></li><li data-type='method'><a href="LoggerBase.html#.isLogger">isLogger</a></li></ul></li><li><a href="MultiLevelAutoNumbering.html">MultiLevelAutoNumbering</a><ul class='methods'><li data-type='method'><a href="MultiLevelAutoNumbering.html#nest">nest</a></li><li data-type='method'><a href="MultiLevelAutoNumbering.html#next">next</a></li><li data-type='method'><a href="MultiLevelAutoNumbering.html#reset">reset</a></li><li data-type='method'><a href="MultiLevelAutoNumbering.html#unnest">unnest</a></li></ul></li><li><a href="NoThrows.html">NoThrows</a></li><li><a href="NodeLogger.html">NodeLogger</a><ul class='methods'><li data-type='method'><a href="NodeLogger.html#colorfy">colorfy</a></li></ul></li><li><a href="SequencesAreEqual.html">SequencesAreEqual</a><ul class='methods'><li data-type='method'><a href="SequencesAreEqual.html#runImpl">runImpl</a></li></ul></li><li><a href="SequentialText.html">SequentialText</a><ul class='methods'><li data-type='method'><a href="SequentialText.html#close">close</a></li><li data-type='method'><a href="SequentialText.html#next">next</a></li><li data-type='method'><a href="SequentialText.html#reset">reset</a></li></ul></li><li><a href="SimpleLogger.html">SimpleLogger</a><ul class='methods'><li data-type='method'><a href="SimpleLogger.html#colorfy">colorfy</a></li><li data-type='method'><a href="SimpleLogger.html#error">error</a></li><li data-type='method'><a href="SimpleLogger.html#group">group</a></li><li data-type='method'><a href="SimpleLogger.html#groupCollapsed">groupCollapsed</a></li><li data-type='method'><a href="SimpleLogger.html#groupEnd">groupEnd</a></li><li data-type='method'><a href="SimpleLogger.html#info">info</a></li><li data-type='method'><a href="SimpleLogger.html#log">log</a></li><li data-type='method'><a href="SimpleLogger.html#prefixMessage">prefixMessage</a></li><li data-type='method'><a href="SimpleLogger.html#warn">warn</a></li></ul></li><li><a href="Test.html">Test</a><ul class='methods'><li data-type='method'><a href="Test.html#.areEqual">areEqual</a></li><li data-type='method'><a href="Test.html#.areNotEqual">areNotEqual</a></li><li data-type='method'><a href="Test.html#.isDefined">isDefined</a></li><li data-type='method'><a href="Test.html#.isFalse">isFalse</a></li><li data-type='method'><a href="Test.html#.isNotNull">isNotNull</a></li><li data-type='method'><a href="Test.html#.isNull">isNull</a></li><li data-type='method'><a href="Test.html#.isTrue">isTrue</a></li><li data-type='method'><a href="Test.html#.isUndefined">isUndefined</a></li><li data-type='method'><a href="Test.html#.noThrows">noThrows</a></li><li data-type='method'><a href="Test.html#.sequencesAreEqual">sequencesAreEqual</a></li><li data-type='method'><a href="Test.html#.throws">throws</a></li></ul></li><li><a href="TestBase.html">TestBase</a><ul class='methods'><li data-type='method'><a href="TestBase.html#run">run</a></li><li data-type='method'><a href="TestBase.html#runImpl">runImpl</a></li><li data-type='method'><a href="TestBase.html#write">write</a></li></ul></li><li><a href="TestGroup.html">TestGroup</a><ul class='methods'><li data-type='method'><a href="TestGroup.html#add">add</a></li><li data-type='method'><a href="TestGroup.html#areEqual">areEqual</a></li><li data-type='method'><a href="TestGroup.html#areNotEqual">areNotEqual</a></li><li data-type='method'><a href="TestGroup.html#clear">clear</a></li><li data-type='method'><a href="TestGroup.html#groupClose">groupClose</a></li><li data-type='method'><a href="TestGroup.html#groupStart">groupStart</a></li><li data-type='method'><a href="TestGroup.html#isDefined">isDefined</a></li><li data-type='method'><a href="TestGroup.html#isFalse">isFalse</a></li><li data-type='method'><a href="TestGroup.html#isNotNull">isNotNull</a></li><li data-type='method'><a href="TestGroup.html#isNull">isNull</a></li><li data-type='method'><a href="TestGroup.html#isTrue">isTrue</a></li><li data-type='method'><a href="TestGroup.html#isUndefined">isUndefined</a></li><li data-type='method'><a href="TestGroup.html#noThrows">noThrows</a></li><li data-type='method'><a href="TestGroup.html#run">run</a></li><li data-type='method'><a href="TestGroup.html#runImpl">runImpl</a></li><li data-type='method'><a href="TestGroup.html#sequencesAreEqual">sequencesAreEqual</a></li><li data-type='method'><a href="TestGroup.html#throws">throws</a></li><li data-type='method'><a href="TestGroup.html#write">write</a></li></ul></li><li><a href="Throws.html">Throws</a></li><li><a href="ThrowsBase.html">ThrowsBase</a><ul class='methods'><li data-type='method'><a href="ThrowsBase.html#runImpl">runImpl</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#SequentialText.">SequentialText.</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">moyal.test.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>﻿/*!
 * moyal.js.test - A lightweight JavaScript testing framework.
 *
 * File: MoyalTest.js
 * Repository: https://github.com/IlanMoyal/moyal.js.test
 * Author: Ilan Moyal (https://www.moyal.es)
 * Contact: ilan.amoyal[guess...what]gmail.com
 *
 * Description:
 * A minimalist, zero-dependency testing library for JavaScript,
 * designed to be embeddable, expressive, and suitable for both
 * browser and Node.js environments.
 *
 * License:
 * MIT License – Permission is granted for free use, modification, and distribution,
 * provided that the copyright notice and license appear in all copies.
 * Full license text: https://opensource.org/licenses/MIT
 *
 * © 2000–present Ilan Moyal. All rights reserved.
 */

import BuildInfo from "./auto-generated/build-info.js";
import InternalUtils from "./_InternalUtils.js";
import { LoggerBase, SimpleLogger, BrowserLogger, NodeLogger } from "./logger.js";
import { AutoNumbering, MultiLevelAutoNumbering, SequentialText } from "./Utils.js";

// Safe timer that always exists
const _now = (typeof performance !== "undefined" &amp;&amp; typeof performance.now === "function")
    ? () => performance.now()
    : () => Date.now();

/**
 * @class Test
 *
 * The main static interface for the moyal.js.test framework.
 * 
 * Provides assertion utilities for test development and a central entry point to define and run tests.
 * Also contains type utilities to assist in dynamic validation.
 *
 * Example usage:
 * ```js
 * Test.isTrue("Test if value is true", myValue);
 * Test.areEqual("Value check", expected, actual);
 * ```
 */

class Test {
    /** @type {LoggerBase} */
    static #_logger = null;

     /**
     * Returns the version of the test library.
     * This is a read-only property used for diagnostics or compatibility checks.
     * @returns {string} Semantic version string.
     */
    static get Version() {
        return BuildInfo.version;
    }

    static get logger() {
        if(this.#_logger == null)
            this.#_logger = LoggerBase.getDefaultLogger();

        return this.#_logger;
    }

    static set logger(logger) {
        if(logger == null)
            this.#_logger  = LoggerBase.getDefaultLogger();

        else if(LoggerBase.isLogger(logger)) 
            this.#_logger = logger;
    }

    /* 
     * Direct test functions 
     */

    /**
     * Asserts strict equality - checks if `actual === expected`, or uses a custom comparer if provided.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} expected - Expected value.
     * @param {*} actual - Actual value to compare.
     * @param {function(any, any):boolean} [comparer] - Optional custom comparison function ((expected, actual) => boolean).
     * @param {?boolean} [write] - The write mode: true - log all; false - don't log anything; null (or undefined) - log only errors.
     * @returns {boolean} True if the test succeeded; otherwise, false.
     */
    static areEqual(testName, expected, actual, comparer, write) { return new AreEqual(testName, expected, actual, comparer).run(write);}

    /**
     * Asserts strict inequality - checks if `actual !== not_expected`, or uses a custom comparer if provided.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} not_expected - The value we not expecting.
     * @param {*} actual - Actual value to compare.
     * @param {function(any, any):boolean} [comparer] - Optional custom comparison function ((not_expected, actual) => boolean).
     * @param {?boolean} [write] - The write mode: true - log all; false - don't log anything; null (or undefined) - log only errors.
     * @returns {boolean} True if the test succeeded; otherwise, false.
     */
    static areNotEqual(testName, not_expected, actual, comparer, write) { return new AreNotEqual(testName, not_expected, actual, comparer).run(write);}

    /**
     * Asserts that specified value is strictly `true`.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} actual - Value to assert is `true`.
     * @param {?boolean} [write] - The write mode: true - log all; false - don't log anything; null (or undefined) - log only errors.
     * @returns {boolean} True if the test succeeded; otherwise, false.
     */
    static isTrue(testName, actual, write) { return new IsTrue(testName, actual).run(write); }

    /**
     * Asserts that specified value is strictly `false`.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} actual - Value to assert is `false`.
     * @param {?boolean} [write] - The write mode: true - log all; false - don't log anything; null (or undefined) - log only errors.
     * @returns {boolean} True if the test succeeded; otherwise, false.
     */
    static isFalse(testName, actual, write) { return new IsFalse(testName, actual).run(write); }

    /**
     * Asserts that the specfied value is strictly `null`.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} actual - Value to assert is `null`.
     * @param {?boolean} [write] - The write mode: true - log all; false - don't log anything; null (or undefined) - log only errors.
     * @returns {boolean} True if the test succeeded; otherwise, false.
     */
    static isNull(testName, actual, write) { return new IsNull(testName, actual).run(write); }
    
    /**
     * Asserts that the specified value is **not** `null`.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} actual - Value to assert is not `null`.
     * @param {?boolean} [write] - The write mode: true - log all; false - don't log anything; null (or undefined) - log only errors.
     * @returns {boolean} True if the test succeeded; otherwise, false.
     */
    static isNotNull(testName, actual, write) {return new IsNotNull(testName, actual).run(write);}

    /**
     * Asserts that specified value is **not** `undefined`.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} actual - Value to assert is defined.
     * @param {?boolean} [write] - The write mode: true - log all; false - don't log anything; null (or undefined) - log only errors.
     * @returns {boolean} True if the test succeeded; otherwise, false.
     */
    static isDefined(testName, actual, write) { return new IsDefined(testName, actual).run(write); }

    /**
     * Asserts that specified value is strictly `undefined`.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} actual - Value to assert is `undefined`.
     * @param {?boolean} [write] - The write mode: true - log all; false - don't log anything; null (or undefined) - log only errors.
     * @returns {boolean} True if the test succeeded; otherwise, false.
     */
    static isUndefined(testName, actual, write) { return new IsUndefined(testName, actual).run(write); }

    /**
     * Adds an assertion that verifies a function throws an error.
     * Optionally verifies the error with a predicate.
     *
     * @param {string} testName - Descriptive test title.
     * @param {function} fn - Function expected to throw.
     * @param {function(any):boolean} [checkErrorFn] - Optional predicate to inspect the thrown error.
     * @param {object} [thisArg] - Optional `this` binding for `fn` and `checkErrorFn`.
     * @param {?boolean} [write] - The write mode: true - log all; false - don't log anything; null (or undefined) - log only errors.
     * @returns {boolean} True if the test succeeded; otherwise, false.
     */
    static throws(testName, fn, checkErrorFn, thisArg, write) { return new Throws(testName, fn, checkErrorFn, thisArg).run(write); }

    /**
     * Adds an assertion that verifies a function does NOT throw.
     *
     * @param {string} testName - Descriptive test title.
     * @param {function} fn - Function expected to execute without throwing.
     * @param {object} [thisArg] - Optional `this` binding for `fn`.
     * @param {?boolean} [write] - The write mode: true - log all; false - don't log anything; null (or undefined) - log only errors.
     * @returns {boolean} True if the test succeeded; otherwise, false.
     */
    static noThrows(testName, fn, thisArg, write) { return new NoThrows(testName, fn, thisArg).run(write);}

    /**
     * Adds a sequence equality assertion to the group.
     * Compares two iterable sequences element-by-element.
     *
     * @param {string} testName - Descriptive test title.
     * @param {Iterable} expected - The expected iterable sequence.
     * @param {Iterable} actual - The actual iterable sequence.
     * @param {function(any, any):boolean} [itemComparer] - Optional custom item-level comparison function ((expected, actual) => boolean).
     * @param {?boolean} [write] - The write mode: true - log all; false - don't log anything; null (or undefined) - log only errors.
     * @returns {boolean} True if the test succeeded; otherwise, false.
     */
    static sequencesAreEqual(testName, expected, actual, itemComparer, write) { return new SequencesAreEqual(testName, expected, actual, itemComparer).run(write); }
}


/**
 * Internal class used by assertions to carry both the result of a test evaluation
 * and any associated metadata (such as expected/actual values) for logging.
 *
 * @private
 * @class
 */
class TestInternalResult{
    /**
     * Indicates if the test passed or failed.
     * 
     * @type {boolean} 
     */
    _result = null;

    /**
     * Additional context (e.g., expected/actual values) to display with the result.
     * 
     * @type {any} 
     */
    _additionalData = null;

    /**
     * Constructs a new result object for use in lazy assertions.
     *
     * @param {boolean} result - The outcome of the test (true/false).
     * @param {any} additionalData - Extra metadata to assist in diagnostics (optional).
     */
    constructor(result, additionalData) {
        this._result = result;
        this._additionalData = additionalData;
    }
}

/**
 * @class BaseTest
 *
 * Abstract base class for all test types.
 * 
 * Provides a unified interface for managing test name, success/failure status, timing, and output.
 * Subclasses must override the `runImpl()` method to implement test logic.
 * @abstract 
 */
class TestBase {
    /** @type {string} */
    #_testName = null;
    
    /** @type {boolean} */
    #_succeeded = true;

    /** @type {string} */
    #_successMessage = null;

    /** @type {string} */
    #_failureMessage = null;

    /** @type {any} */
    #_additionalData = null;

    /** @type {Array&lt;Error>} */
    #_errors = [];

    /** @type {number} */
    #_elapsed = 0;

    /**
     * Base class for all test types.
     * 
     * This class defines the common interface for test name, result summary,
     * success/failure messages, optional data, and a way to log results.
     *
     * @param {string} testName - The name of the test (must be string).
     * @param {string} [successMessage="success"] - Message when the test passes.
     * @param {string} [failureMessage="failure"] - Message when the test fails.
     * @param {any} [additionalData] - Arbitrary data to show with test output.
     */
    constructor(testName, successMessage, failureMessage, additionalData) {
        if (!InternalUtils.isString(testName)) { throw new Error("testName must be string"); }
        if (successMessage != null &amp;&amp; !InternalUtils.isString(successMessage)) { throw new Error("successMessage must be string, null or undefined"); }
        if (failureMessage != null &amp;&amp; !InternalUtils.isString(failureMessage)) { throw new Error("failureMessage must be string, null or undefined"); }
        this.#_testName = testName;
        this.#_successMessage = successMessage ?? "success";
        this.#_failureMessage = failureMessage ?? "failure";
        this.#_additionalData = additionalData;
	}

    /** @returns {string} The name of the test */
    get name() { return this.#_testName; }

    /** @returns {string} The message to display on test success */
    get successMessage() { return this.#_successMessage; }

    /** @returns {string} The message to display on test failure */
    get failureMessage() { return this.#_failureMessage; }

    /**
     * Gets the duration in milliseconds.
     * 
     * @returns {number} The duration in milliseconds. */
    get elapsed() { return this.#_elapsed; } /* milliseconds*/

    /** 
     * Sets the time elapsed.
     * 
     * @param {number} value - Duration in milliseconds
     */
    set elapsed(value) {  this.#_elapsed = value; } /* milliseconds*/

    /** @returns {boolean} Whether the test passed — overridden in derived classes */
    get succeeded() { return this.#_succeeded;}
    
    /**
     * Sets a value indicating whether the test passed.
     * @param {boolean} value - A value indicating whether the test passed.
     */
    set succeeded(value) { this.#_succeeded = (value === true);}

    /** @returns {boolean} Whether the test failed (inverse of succeeded) */
    get failed() { return this.succeeded !== true; }

    /** @returns {Array&lt;Error>} List of errors associated with the test */
    get errors() { return this.#_errors; }

    /** @returns {number} Count of errors (possibly from child tests) */
    get errorCount() { return this.errors.length; } /* might be the count of inner tests' errors, so in derived class might be positive even though the errors collection is null! */
    
    /** 
     * Gets extra information to log with the test.
     * 
     * @returns {any} Extra information to log with the test  
     */
    get additionalData() { return this.#_additionalData; }

    /** 
     * Sets extra information to log with the test.
     * 
     * @param {any} value The additional data.
     */
    set additionalData(value) { this.#_additionalData = value; }

    /**
     * Runs the test and optionally writes its result.
     * 
     * @param {boolean} write - If true, writes the result to the console; 
     *          If false doesn't write the result to the console; 
     *          Otherwise writes only failures to the console.
     * @param {MultiLevelAutoNumbering} [mlAutoNumber] - Optional multi-level automatic numbering to automatically prefix messages with numbers.
     * @returns {boolean} Whether the test passed.
     */
    run(write, mlAutoNumber) { 
        this.succeeded = this.runImpl();
        if (write === true || (write !== false &amp;&amp; !this.succeeded)) {
            this.write(mlAutoNumber);
		}
        return this.succeeded;
    }

    /**
     * Runs the test without printing.
     * 
     * @returns {boolean} Whether the test passed.
     * @abstract
     */
    runImpl() {
        throw new Error("Method 'runImpl()' must be implemented by subclass");
    }

    /**
     * Pushes the specified error to the error list.
     * 
     * @param {Error} e - The error.
     * @ignore
     */
    _push_error(e){
        this.#_errors.push(e);
    }

    /**
     * Logs the result of the test to the console.
     * 
     * If the test passes with no errors, it uses a flat `console.log`.
     * If there are errors or additional data, it uses a collapsed group for clarity.
     * @param {MultiLevelAutoNumbering} [mlAutoNumber] - Optional multi-level automatic numbering to automatically prefix messages with numbers. 
     */
    write(mlAutoNumber) {
        if(mlAutoNumber == null || !(mlAutoNumber instanceof MultiLevelAutoNumbering)) 
            mlAutoNumber = null;
        
        const labelName = this.name?.trim() || "(unnamed test)";
        let label = `${(mlAutoNumber?.next() ?? "")}${labelName}: ${(this.succeeded ? this.successMessage : this.failureMessage)} (${this.elapsed} ms`
        let color = this.succeeded ? "green" : "red";
        if (this.errorCount === 0) {
            label += ")";
        }
        else {
            let errorStr = (this.succeeded ? "" : "un") + "expected " + (this.errorCount > 1 ? "errors" : "error");
            label += `, ${this.errorCount} ${errorStr})`;
        }

        if (this.errorCount == 0 &amp;&amp; this.additionalData == null) {
            // Simple success case
            Test.logger.log(label, color);
            return;
        }
        
        // Grouped output with errors or extra info
        Test.logger.groupCollapsed(label, color);

        // Show errors if available
        if (this.errorCount > 0) {
            if (this.additionalData != null) {
                Test.logger.groupCollapsed("errors");
            }
            /*
             * Available colors:
             *   "black", "red", "green", "yellow", "blue", "magenta", "cyan", "white", "gray", "lightred", 
             *   "lightgreen", "lightyellow", "lightblue", "lightmagenta", "lightcyan", "lightgray"
             */
            for (let err of this.errors) {
                if(this.succeeded)                    
                    Test.logger.error(err, "black");
                else
                    Test.logger.error(err);
            }
            if (this.additionalData != null) {
                Test.logger.groupEnd();
            }
        }

        // Show additional data if available
        if (this.additionalData != null) {
            if (this.errorCount > 0) {
                Test.logger.groupCollapsed("additional data");
            }
            Test.logger.log(this.additionalData);
            if (this.errorCount > 0) {
                Test.logger.groupEnd();
            }
        }

        Test.logger.groupEnd();
    }
}

/**
 * @class Assert
 *
 * A generic assertion test class that evaluates either a boolean or a function returning boolean.
 * 
 * Inherits from {@link TestBase}.
 * Typically used for boolean tests or custom logic.
 */
class Assert extends TestBase {
    // Holds the test logic, result, context, error and timing info
    /** @type {(function|boolean)} */
    #_test = null;

    /** @type {any} */
    #_thisArg = null;

    /**
     * A test that evaluates a function or boolean and tracks its result.
     * 
     * If the test value is a function, it's called and timed.
     * If the function throws, it fails and captures the error.
     * 
     * @param {string} testName - Name of the test.
     * @param {(function|boolean)} test - Test logic (function or static boolean).
     * @param {string} [successMessage] - Custom message on success.
     * @param {string} [failureMessage] - Custom message on failure.
     * @param {any} [additionalData] - Extra data to log.
     * @param {any} [thisArg=globalThis] - `this` context to bind when calling the function.
     */
    constructor(testName, test, successMessage, failureMessage, additionalData, thisArg) {
        super(testName, successMessage, failureMessage, additionalData);
        this.#_test = test;
        this.#_thisArg = thisArg ?? globalThis;
    }

    /**
     * Runs the test without printing.
     * 
     * @returns {boolean} Whether the test passed.
     * @override
     * @ignore
     */
    runImpl() {
        if (this.#_test === true) 
            return true;

        if (!InternalUtils.isFunction(this.#_test))
            return false; // Test is neither true nor a function

        let res;
        const t0 = _now();
        try {
            let tmp =  this.#_test.call(this.#_thisArg);
            if(tmp instanceof TestInternalResult){
                this.additionalData = tmp._additionalData;
                res = tmp._result === true;
            }
            else {
                res = tmp;
            }
        }
        catch (e) {
            this._push_error(e);
            res = false;
        }
        const t1 = _now();
        this.elapsed = t1 - t0;

        return res;
    }
};

/**
 * @class AreEqual
 *
 * A test that compares two values using strict equality (`===`) or a custom comparer function.
 *
 * Inherits from {@link Assert}.
 */
class AreEqual extends Assert {
    /**
     * Compares two values using `===` or a custom comparer function.
     * Values can be passed directly or as functions for deferred evaluation.
     *
     * @param {string} testName - Name of the test.
     * @param {any|Function} expected - Expected value or function returning it.
     * @param {any|Function} actual - Actual value or function returning it.
     * @param {function(any, any):boolean} [comparer] - Optional custom comparison function ((expected, actual) => boolean).
     * @param {any} [thisArg] - Optional context for invoking deferred or comparison functions.
     */
    constructor(testName, expected, actual, comparer, thisArg) {
        // Use the comparer if provided, otherwise compare using strict equality
        let needsDelayedExecution = InternalUtils.isFunction(expected) || InternalUtils.isFunction(actual) || InternalUtils.isFunction(comparer);        
        let test;
        let ad = null;
        if(needsDelayedExecution){
            test = () => {
                let expectedVal = InternalUtils.isFunction(expected) ? expected.call(thisArg ?? globalThis) : expected;
                let actualVal   = InternalUtils.isFunction(actual)   ? actual.call(thisArg ?? globalThis)   : actual;

                return new TestInternalResult(
                    InternalUtils.isFunction(comparer)  ? comparer.call(thisArg ?? globalThis, expectedVal, actualVal) : expectedVal === actualVal,
                    { "expected": expectedVal, "actual": actualVal }
                );
            }
        }
        else {
            test = expected === actual;
            ad = { "expected": expected, "actual": actual };
        }
        super(testName, 
            test, 
            "Expected and actual values matched", 
            "Expected and actual values did not match", 
            ad,
            thisArg);
    }
}

/**
 * @class AreNotEqual
 *
 * A test that verifies two values are **not equal** using strict inequality (`!==`)
 * or a custom comparer function that is expected to return `false`.
 *
 * This test passes when `actual !== not_expected`, or when the `comparer` returns `false`.
 *
 * Inherits from {@link Assert}.
 *
 * Example:
 * ```js
 * new AreNotEqual("Should be different", 42, value);
 * new AreNotEqual("Custom inequality", a, b, (a, b) => deepCompare(a, b));
 * ```
 */
class AreNotEqual extends Assert {
    /**
     * Constructs a new inequality assertion.
     *
     * @param {string} testName - Name of the test.
     * @param {any|Function} not_expected - Value the actual result must NOT match.
     * @param {any|Function} actual - Actual value or function returning it.
     * @param {function(any, any):boolean} [comparer] - Optional custom comparison function ((not_expected, actual) => boolean).
     * @param {any} [thisArg] - Optional context for invoking deferred or comparison functions.
     */
    constructor(testName, not_expected, actual, comparer, thisArg) {
        // Use the comparer if provided, otherwise compare using strict equality
        let needsDelayedExecution = InternalUtils.isFunction(not_expected) || InternalUtils.isFunction(actual) || InternalUtils.isFunction(comparer);        
        let test;
        let ad = null;
        if(needsDelayedExecution){
            test = () => {
                let not_expectedVal = InternalUtils.isFunction(not_expected) ? not_expected.call(thisArg ?? globalThis) : not_expected;
                let actualVal   = InternalUtils.isFunction(actual)   ? actual.call(thisArg ?? globalThis)   : actual;

                return new TestInternalResult(
                    InternalUtils.isFunction(comparer) ? !comparer.call(thisArg ?? globalThis, not_expectedVal, actualVal) : not_expectedVal !== actualVal,
                    { "not_expected": not_expectedVal, "actual": actualVal }
                );
            }
        }
        else {
            test = not_expected !== actual;
            ad = { "not_expected": not_expected, "actual": actual };
        }

        super(testName, 
            test, 
            "Actual value did not match the disallowed value (as expected!)",
            "Actual value matched the disallowed value (not as expected!)",
            ad,
            thisArg);
    }
}

/**
 * @class IsTrue
 *
 * A test that asserts the actual value is strictly `true`.
 * 
 * Can accept a boolean value or a function returning boolean.
 *
 * Inherits from {@link Assert}.
 */
class IsTrue extends AreEqual {
    /**
     * Asserts that a value is strictly `true`.
     *
     * @param {string} testName - The name of the test.
     * @param {any|Function} actual - The value or function to evaluate.
     * @param {any} [thisArg] - Optional context in which to invoke deferred evaluation.
     */
    constructor(testName, actual, thisArg) {
        super(testName, true, actual, null, thisArg);
    }
}

/**
 * @class IsFalse
 *
 * A test that asserts the actual value is strictly `false`.
 * 
 * Can accept a boolean value or a function returning boolean.
 *
 * Inherits from {@link Assert}.
 */
class IsFalse extends AreEqual {
    /**
     * Asserts that a value is strictly `false`.
     *
     * @param {string} testName - The name of the test.
     * @param {any|Function} actual - The value or function to evaluate.
     * @param {any} [thisArg] - Optional context for evaluation.
     */
    constructor(testName, actual, thisArg) {
        super(testName, false, actual, null, thisArg);
    }
}

/**
 * @class IsNull
 *
 * A test that asserts the actual value is strictly `null`.
 *
 * Inherits from {@link Assert}.
 *
 * Example:
 * ```js
 * isNull("Should be null", myValue);
 * ```
 */
class IsNull extends AreEqual {
    /**
     * Constructs a null-check assertion.
     *
     * @param {string} testName - Descriptive name of the test.
     * @param {any|Function} actual - Value to test or function that returns it.
     * @param {any} [thisArg] - Optional context for function calls.
     */
    constructor(testName, actual, thisArg) {
        super(testName, null, actual, null, thisArg);
    }
}

/**
 * @class IsNotNull
 *
 * A test that asserts the actual value is **not** `null`.
 *
 * Inherits from {@link Assert}.
 *
 * Example:
 * ```js
 * isNotNull("Should not be null", myValue);
 * ```
 */
class IsNotNull extends AreNotEqual {
    /**
     * Constructs a not-null assertion.
     *
     * @param {string} testName - Descriptive name of the test.
     * @param {any|Function} actual - Value to check.
     * @param {any} [thisArg] - Optional context for invocation.
     */
    constructor(testName, actual, thisArg) {
        super(testName, null, actual, null, thisArg);
    }
}

/**
 * @class IsDefined
 *
 * A test that asserts the actual value is **not** `undefined`.
 *
 * Inherits from {@link Assert}.
 *
 * Example:
 * ```js
 * isDefined("Value should be defined", myValue);
 * ```
 */
class IsDefined extends AreNotEqual {
    /**
     * Constructs a defined-check assertion.
     *
     * @param {string} testName - Descriptive name of the test.
     * @param {any|Function} actual - Value to evaluate or function to call.
     * @param {any} [thisArg] - Optional context for evaluation.
     */
    constructor(testName, actual, thisArg) {
        super(testName, undefined, actual, null, thisArg);
    }
}

/**
 * @class IsUndefined
 *
 * A test that asserts the actual value is strictly `undefined`.
 *
 * Inherits from {@link Assert}.
 *
 * Example:
 * ```js
 * isUndefined("Should be undefined", maybeMissing);
 * ```
 */
class IsUndefined extends AreEqual {
     /**
     * Constructs an undefined-check assertion.
     *
     * @param {string} testName - Descriptive name of the test.
     * @param {any|Function} actual - Value to test or a function that returns it.
     * @param {any} [thisArg] - Optional context for deferred invocation.
     */
    constructor(testName, actual, thisArg) {
        super(testName, undefined, actual, null, thisArg);
    }
}

/**
 * @class ThrowsBase
 *
 * Base class for tests that evaluate whether a function throws or not.
 * 
 * Supports optional error validation via predicate functions.
 *
 * Inherits from {@link Assert}.
 * Not used directly — use {@link Throws} or {@link NoThrows} instead.
 */
class ThrowsBase extends Assert {
    /** @type {function} */
    #_checkErrorFn = null;

    /** @type {any} */
    #_thisArg = null;

    /** @type {boolean} */
    #_expected = true;

    /**
     * Base class to test whether a function throws (or not), and optionally validate the error thrown.
     *
     * @param {string} testName - Name of the test.
     * @param {boolean} expectingError - Whether an error is expected (`true` = should throw).
     * @param {function} fn - Function to test.
     * @param {function(any):boolean} [checkErrorFn] - Optional error predicate to validate the thrown error.
     * @param {any} [thisArg] - Optional `this` context for invoking the test/check function.
     */
    constructor(testName, expectingError, fn, checkErrorFn, thisArg) {
        expectingError = (expectingError === true);
        const errWasThrownAsExpected = "An error was thrown (as expected)!"; 
        const errWasNotThrownAsExpected = "An error was NOT thrown (as expected)."; 
        const errExpectedFail = "Expected an error, but none was thrown or it did not satisfy the predicate."; 
        const errWasThrownAsUnexpectedly = "An error was not thrown (unexpectedly)."; 

        super(testName, fn, 
            expectingError ? errWasThrownAsExpected : errWasNotThrownAsExpected, 
            expectingError ? errExpectedFail : errWasThrownAsUnexpectedly, 
            thisArg);
        if (!InternalUtils.isFunction(fn)) { throw new Error("fn parameter must be a function"); }
        if (expectingError &amp;&amp; checkErrorFn != null &amp;&amp; !InternalUtils.isFunction(checkErrorFn)) { throw new Error("checkErrorFn parameter must be a function, null or undefined"); }
        this.#_expected = expectingError;
        this.#_thisArg = thisArg;
        this.#_checkErrorFn = checkErrorFn;
    }

    
    /**
     * Executes the test, checking if an error was thrown and optionally applying a predicate on the error.
     * 
     * @returns {boolean} Whether the test passed.
     * @override 
     */
    runImpl() {
        const basePassed = super.runImpl();

        if (!basePassed &amp;&amp; this.errors.length === 1) {
            return this.#_expected &amp;&amp; (this.#_checkErrorFn == null || this.#_checkErrorFn.call(this.#_thisArg, this.errors[0]) === true);
        }
        return !this.#_expected; 
    }
}

/**
 * @class Throws
 *
 * A test that expects a function to throw an exception.
 * 
 * You may optionally provide a predicate to verify the thrown error.
 *
 * Inherits from {@link ThrowsBase}.
 */
class Throws extends ThrowsBase {
    /**
     * Tests that a function throws, and optionally that the thrown error satisfies a condition.
     *
     * @param {string} testName - Name of the test.
     * @param {function} fn - The function that should throw.
     * @param {function(any):boolean} [checkErrorFn] - Optional error predicate.
     * @param {any} [thisArg] - Optional `this` context.
     */
    constructor(testName, fn, checkErrorFn, thisArg) {
        super(testName, true, fn, checkErrorFn, thisArg);
    }
}

/**
 * @class NoThrows
 *
 * A test that verifies a function does not throw any error.
 *
 * Inherits from {@link ThrowsBase}.
 */
class NoThrows extends ThrowsBase {
    /**
     * Tests that a function does NOT throw.
     *
     * @param {string} testName - Name of the test.
     * @param {?function} fn - The function to test.
     * @param {any} [thisArg] - Optional `this` context.
     */
    constructor(testName, fn, thisArg) {
        super(testName, false, fn, null, thisArg);
    }
}

/**
 * @class SequencesAreEqual
 *
 * A test that compares two iterable sequences element-by-element for equality.
 * 
 * You can supply a custom item comparison function. Results include index mismatches.
 *
 * Inherits from {@link TestBase}.
 */
class SequencesAreEqual extends TestBase {
    /** @type {Iterable&lt;any>} */
    #_expected = null;

    /** @type {Iterable&lt;any>} */
    #_actual = null;

    /** @type {function} */
    #_itemComparer = null;

    /** @type {boolean} */
    #_validIterables = true;

    /** @type {any} */
    #_thisArg = null;

    /**
     * Compares two iterable sequences element by element.
     * 
     * @param {string} testName - Name of the test.
     * @param {Iterable&lt;any>} expected - Expected sequence.
     * @param {Iterable&lt;any>} actual - Actual sequence.
     * @param {function(any, any):boolean} [itemComparer] - Optional custom comparison function to compare individual items ((expected, actual) => boolean).
     * @param {any} [thisArg] - Optional `this` binding for the itemComparer.
     */
    constructor(testName, expected, actual, itemComparer, thisArg) {
        // Call Assert constructor with all info
        super(testName, `Actual sequence equals to the expected sequence`, `Actual sequence does not equal to the expected sequence)`, null, thisArg);
        this.additionalData = {};

        this.#_expected = expected;
        this.#_actual = actual;
        this.#_itemComparer = itemComparer;
        this.#_thisArg = thisArg;

        // Validate that expected is iterable
        if (!InternalUtils.isIterable(expected)) {
            this.additionalData["expected"] = "ERROR: 'expected' argument is not iterable!"
            this.#_validIterables = false;
        }

        // Validate that actual is iterable
        if (!InternalUtils.isIterable(actual)) {
            this.additionalData["actual"] = "ERROR: 'actual' argument is not iterable!"
            this.#_validIterables = false;
        }
    }

    /**
     * Runs the test without printing.
     * 
     * @returns {boolean} Whether the test passed.
     * @override 
     */
    runImpl() {
        if(!this.#_validIterables) 
            return false;
        
        const t0 = _now();

        let expectedArr = this.additionalData["expected"] = Array.from(this.#_expected);
        let actualArr = this.additionalData["actual"] = Array.from(this.#_actual);
        let res;

        // Check lengths
        if (expectedArr.length === actualArr.length) {
            // Check individual items
            let indicesDifferent = [];
            for (var i = 0; i &lt; expectedArr.length; i++) {
                let res = this.#_itemComparer != null ? this.#_itemComparer.call(this.#_thisArg ?? undefined, expectedArr[i], actualArr[i]) : expectedArr[i] === actualArr[i];
                if (res !== true) {
                    indicesDifferent.push(i);
                }
            }

            if (indicesDifferent.length > 0)
                this.additionalData["Mismatch at indices"] = "Different element indices are: {" + indicesDifferent.join(", ") + "}";

            res = indicesDifferent.length === 0;
        }
        else{
            this.additionalData["Mismatch at indices"] = "expected.length !== actual.length";
            res = false;
        }

        const t1 = _now();
        this.elapsed = t1 - t0;

        return res;
    }
}

/**
 * @class TestGroup
 *
 * A container for managing and executing multiple tests (or nested groups of tests).
 * 
 * Automatically aggregates success/failure counts and outputs structured logs.
 * 
 * Supports fluent-style chaining:
 * ```js
 * group.isTrue("A", true)
 *      .areEqual("Compare", 1, 1)
 *      .throws("Expect error", () => { throw new Error(); });
 *      .groupStart("another group")
 *              .areEqual("Compare", 3, 3)
 *              .throws("Expect error", () => { throw new Error(); });
 *      .groupClose()
 *      .run();
 * ```
 *
 * Inherits from {@link TestBase}.
 */
class TestGroup extends TestBase {
    /** @type {Array&lt;TestBase>} */
    #_tests = [];

    /** @type {number} */
    #_directFailureCount = 0;

    /** @type {number} */
    #_totalFailureCount = 0;

    /** @type {number} */
    #_totalErrorCount = 0;

    /** @type {number} */
    #_unexpectedErrorCount = 0;

    /** @type {TestGroup|null} */
    #_parentGroup = null;

    /** @type {boolean|null} */
    #_write = null; // Controls output policy for child test writes (true, false, or conditional)

    /**
     * Creates a new test group to encapsulate multiple tests or nested groups.
     *
     * @param {string} testName - The name/title of this group.
     * @param {...TestBase} tests - Optional tests or nested groups to immediately add.
     */
    constructor(testName, ...tests) {
        super(testName);
        this.add(...tests);
    }

    /** 
     * Clears all tests in this group. 
     * 
     * @public
     */
    clear() { 
        this.#_tests.length = 0;
        this.#_directFailureCount = 0;
        this.#_totalFailureCount = 0;
        this.#_totalErrorCount = 0;
        this.#_unexpectedErrorCount = 0;
    }

    /** @returns {number} Total number of errors found (including nested groups). */
    get errorCount() { return this.#_totalErrorCount; }

    /**
     * Runs the test and optionally writes its result.
     * 
     * @param {boolean} write - If true, writes the result to the console; 
     *          If false doesn't write the result to the console; 
     *          Otherwise writes only failures to the console.
     * @param {MultiLevelAutoNumbering} [mlAutoNumber] - Optional multi-level automatic numbering to automatically prefix messages with numbers.
     * @returns {boolean} Whether the test passed.
     * @override
     */
    run(write, mlAutoNumber){
        this.#_write = write;
        return super.run(write, mlAutoNumber);
    }
    /**
     * Executes all tests/groups in this group without printing.
     * Aggregates error and timing info, but delays output if `write` is false.*
     
     * @returns {boolean} True if all direct tests succeeded.
     * @override 
     */
    runImpl() {
        this.#_directFailureCount = 0;
        this.#_totalErrorCount = 0;
        this.#_unexpectedErrorCount = 0;
        
        const t0 = _now();
        for (let t of this.#_tests) {
            t.runImpl(); 

            this.#_directFailureCount += t.succeeded ? 0 : 1;

            if (t instanceof TestGroup) {
                // Accumulate from nested groups
                this.#_totalFailureCount += t.#_totalFailureCount;
                this.#_unexpectedErrorCount += t.#_unexpectedErrorCount;
            }
            else {
                // Leaf tests
                this.#_totalFailureCount = this.#_directFailureCount;
                this.#_unexpectedErrorCount += t.succeeded ? 0 : t.errorCount;
            }

            this.#_totalErrorCount += t.errorCount;
        }
        const t1 = _now();
        this.elapsed = t1 - t0;
        
        return this.#_directFailureCount === 0;
    }

    /**
     * Outputs a summary line and recursively logs all child test results.
     * Uses collapsed group for passed tests and expanded group for failed ones.
     * 
     * @param {MultiLevelAutoNumbering} [mlAutoNumber] - Optional multi-level automatic numbering to automatically prefix messages with numbers.
     * @override
     */
    write(mlAutoNumber) {
        if(mlAutoNumber == null || !(mlAutoNumber instanceof MultiLevelAutoNumbering))
            mlAutoNumber = null;

        let label = `${(mlAutoNumber?.next() ?? "")}${this.name}: (${this.elapsed}ms, `;
        let color;
        if (this.#_directFailureCount === 0) {
            color = "green";
            label += "all passed"
        }
        else {
            color = "red";
            if (this.#_directFailureCount > 0) {
                label += `${this.#_directFailureCount} direct failure${(this.#_directFailureCount === 1 ? "" : "s")}, ${this.#_totalFailureCount} total failure${(this.#_totalFailureCount === 1 ? "" : "s")}`;
            }
        }

        if (this.#_unexpectedErrorCount> 0) {
            label += `, ${this.#_unexpectedErrorCount} unexpected error${(this.#_unexpectedErrorCount > 1 ? "s" : "")}`;
        }

        label += ")";

        if (this.succeeded) {
            Test.logger.groupCollapsed(label, color);
        }
        else {
            Test.logger.group(label, color);
		}
        if(this.#_tests?.length > 0) {
            mlAutoNumber?.nest()
            for (let t of this.#_tests) {
                if(this.#_write === true || (this.#_write == null &amp;&amp; !t.succeeded)) {
                    t.write(mlAutoNumber);
                }
            }
            mlAutoNumber?.unnest();
        }
        Test.logger.groupEnd();
    }

    /**
     * Adds tests or groups to this group.
     *
     * @param {...TestBase} tests - One or more test/group instances.
     */
    add(...tests) {
        this.#_tests.push(...tests);
        for (let t of tests) {
            if (t instanceof TestGroup) {
                t.#_parentGroup = this;
			}
		}
    }

    /**
     * Begins a new nested group and automatically adds it to this group.
     *
     * @param {string} testName - The name of the nested group.
     * @returns {TestGroup} The new nested group.
     */
    groupStart(testName) {
        let grp = new TestGroup(testName);
        this.add(grp);
        return grp;
    }

    /**
     * Ends the current group and returns its parent, if any.
     * Enables fluid chaining of group nesting.
     *
     * @returns {TestGroup} - The parent group or `this` if already root.
     */
    groupClose() {
        return this.#_parentGroup ?? this;
    }

    /**
     * Adds an equality assertion to the group.
     * Checks if `actual === expected`, or uses a custom comparer if provided.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} expected - Expected value.
     * @param {*} actual - Actual value to compare.
     * @param {function(any, any):boolean} [comparer] - Optional custom comparison function ((expected, actual) => boolean).
     * @param {any} [thisArg] - Optional context for evaluation.
     * @returns {TestGroup} The current test group (for chaining).
     */
    areEqual(testName, expected, actual, comparer, thisArg) { this.add(new AreEqual(testName, expected, actual, comparer, thisArg)); return this; }

     /**
     * Adds an inequality assertion to the group.
     * Checks if `actual !== not_expected`, or uses a custom comparer if provided.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} not_expected - The value we're not expecting.
     * @param {*} actual - Actual value to compare.
     * @param {function(any, any):boolean} [comparer] - Optional custom comparison function ((expected, actual) => boolean).
     * @param {any} [thisArg] - Optional context for evaluation.
     * @returns {TestGroup} The current test group (for chaining).
     */
     areNotEqual(testName, not_expected, actual, comparer, thisArg) { this.add(new AreNotEqual(testName, not_expected, actual, comparer, thisArg)); return this; }

    /**
     * Adds an assertion to the group that verifies a value is `true`.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} actual - Value to assert is `true`.
     * @param {any} [thisArg] - Optional context for evaluation.
     * @returns {TestGroup} The current test group (for chaining).
     */
    isTrue(testName, actual, thisArg = null) { this.add(new IsTrue(testName, actual, thisArg)); return this; }

    /**
     * Adds an assertion to the group that verifies a value is `false`.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} actual - Value to assert is `false`.
     * @param {any} [thisArg] - Optional context for evaluation.
     * @returns {TestGroup} The current test group (for chaining).
     */
    isFalse(testName, actual, thisArg) { this.add(new IsFalse(testName, actual, thisArg)); return this; }

    /**
     * Adds an assertion to the group that verifies a value is strictly `null`.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} actual - Value to assert is `null`.
     * @param {any} [thisArg] - Optional context for evaluation.
     * @returns {TestGroup} The current test group (for chaining).
     */
    isNull(testName, actual, thisArg) { this.add(new IsNull(testName, actual, thisArg)); return this; }
    
    /**
     * Adds an assertion to the group that verifies a value is **not** `null`.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} actual - Value to assert is not `null`.
     * @param {any} [thisArg] - Optional context for evaluation.
     * @returns {TestGroup} The current test group (for chaining).
     */
    isNotNull(testName, actual, thisArg = null) {this.add(new IsNotNull(testName, actual, thisArg)); return this;}

     /**
     * Adds an assertion to the group that verifies a value is **not** `undefined`.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} actual - Value to assert is defined.
     * @param {any} [thisArg] - Optional context for evaluation.
     * @returns {TestGroup} The current test group (for chaining).
     */
    isDefined(testName, actual, thisArg = null) { this.add( new IsDefined(testName, actual, thisArg));  return this;}

    /**
     * Adds an assertion to the group that verifies a value is strictly `undefined`.
     *
     * @param {string} testName - Descriptive test title.
     * @param {*} actual - Value to assert is `undefined`.
     * @param {any} [thisArg] - Optional context for evaluation.
     * @returns {TestGroup} The current test group (for chaining).
     */
    isUndefined(testName, actual, thisArg = null) { this.add( new IsUndefined(testName, actual, thisArg));  return this;}
    
    /**
     * Adds an assertion that verifies a function throws an error.
     * Optionally verifies the error with a predicate.
     *
     * @param {string} testName - Descriptive test title.
     * @param {function} fn - Function expected to throw.
     * @param {function(any):boolean} [checkErrorFn] - Optional predicate to inspect the thrown error.
     * @param {any} [thisArg] - Optional context for evaluation.
     * @returns {TestGroup} The current test group (for chaining).
     */
    throws(testName, fn, checkErrorFn, thisArg = null) { this.add(new Throws(testName, fn, checkErrorFn, thisArg)); return this; }

    /**
     * Adds an assertion that verifies a function does NOT throw.
     *
     * @param {string} testName - Descriptive test title.
     * @param {function} fn - Function expected to execute without throwing.
     * @param {object} [thisArg] - Optional `this` binding for `fn`.
     * @returns {TestGroup} The current test group (for chaining).
     */
    noThrows(testName, fn, thisArg = null) { this.add(new NoThrows(testName, fn, thisArg)); return this; }

    /**
     * Adds a sequence equality assertion to the group.
     * Compares two iterable sequences element-by-element.
     *
     * @param {string} testName - Descriptive test title.
     * @param {Iterable} expected - The expected iterable sequence.
     * @param {Iterable} actual - The actual iterable sequence.
     * @param {function(any, any):boolean [itemComparer] - Optional custom item-level comparison function ((expected, actual) => boolean).
     * @returns {TestGroup} The current test group (for chaining).
     */
    sequencesAreEqual(testName, expected, actual, itemComparer) { this.add(new SequencesAreEqual(testName, expected, actual, itemComparer)); return this; }
}

const MoyalTest = {
    Test,
    TestBase,
    Assert,
    IsDefined,
    IsUndefined,
    IsFalse,
    IsTrue,
    IsNull,
    IsNotNull,
    AreEqual,
    AreNotEqual,
    ThrowsBase,
    Throws,
    NoThrows,
    SequencesAreEqual,
    TestGroup,

    /* numerators */
    SequentialText,
    AutoNumbering,
    MultiLevelAutoNumbering,

    /* logging */
    LoggerBase,
    SimpleLogger,
    BrowserLogger,
    NodeLogger
};

export default MoyalTest;

export {
    Test,
    TestBase,
    Assert,
    IsDefined,
    IsUndefined,
    IsFalse,
    IsTrue,
    IsNull,
    IsNotNull,
    AreEqual,
    AreNotEqual,
    ThrowsBase,
    Throws,
    NoThrows,
    SequencesAreEqual,
    TestGroup,
    
    /* numerators */
    SequentialText,
    AutoNumbering,
    MultiLevelAutoNumbering,

    /* logging */
    LoggerBase,
    SimpleLogger,
    BrowserLogger,
    NodeLogger
};</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.4</a> on Fri May 02 2025 01:14:59 GMT+0300 (שעון ישראל (קיץ)) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
